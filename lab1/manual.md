gcc -E hello.c -o hello.i
gcc -s hello.c -o hello.s
gcc -c hello.c -o hello.o
gcc hello.o -o hello

1.预编译

操作步骤：gcc -E hello.c -o hello.i

主要作用：处理关于 “#” 的指令

【1】删除#define，展开所有宏定义。例#define portnumber 3333

【2】处理条件预编译 #if, #ifdef, #if, #elif,#endif

【3】处理“#include”预编译指令，将包含的“.h”文件插入对应位置。这可是递归进行的，文件内可能包含其他“.h”文件

【4】删除所有注释 

【5】添加行号和文件标识符。用于显示调试信息：错误或警告的位置

【6】保留#pragma编译器指令
	
	（1）设定编译器状态

	（2）指示编译器完成一些特定的动作


2.编译

操作步骤：gcc -s hello.c -o hello.s

主要作用：1.扫描（词法分析）
		
		 2.语法分析

		 3.语义分析

		 4.源代码优化（中间语言生成）

		 5.代码生成，目标代码优化。

【1】将源代码程序输入扫描器，将源代码的字符序列分割成一系列记号。
	
	例	array[index] =  (index + 4) * (2 + 6)

【2】基于词法分析得到的一系列记号，生成语法树


【3】由语义分析器完成，指示判断是否合法，并不判断对错。又分静态语义和动态语义
	
	静态语义：隐含浮点型到整形的转换，会报warning

 	动态语义：在运行时才能确定

 	例	1除以3


【4】中间代码（语言）使得编译器分为前端和后端，前端产生与机器（或环境）无关的中间代码，编译器的后端将中间代码转换为目标机器代码，目的：一个前端对多个后端，适应不同平台


【5】编译器后端主要包括：代码生成器:依赖于目标机器，依赖目标机器的不同字长，寄存器，数据类型等

    目标代码优化器:选择合适的寻址方式，左移右移代替乘除，删除多余指令

3.汇编

操作步骤：gcc -c hello.c -o hello.o

主要作用：汇编器是将汇编代码转变成可以执行的指令，生成目标文件


4.链接

操作步骤：gcc hello.o -o hello

主要作用：通过编译器的5个步骤后，我们获得目标代码，但是里面的各个地址还没有确定，空间还没有分配

链接过程主要包括：地址和空间的分配，符号决议和重定位

	符号决议：也可以说地址绑定，分动态链接和静态链接

	重定位：假设此时又两个文件：A，B。A需要B中的某个函数mov的地址，未链接前将地址置为0，当A与B链接后修改目标地址，完成重定位